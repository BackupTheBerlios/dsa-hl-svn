/* This source file is part of Rastullahs Lockenpracht.
* Copyright (C) 2003-2005 Team Pantheon. http://www.team-pantheon.de
* 
*  This program is free software; you can redistribute it and/or modify
*  it under the terms of the Clarified Artistic License.
*
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  Clarified Artistic License for more details.
*
*  You should have received a copy of the Clarified Artistic License
*  along with this program; if not you can get it here
*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
*/

/**
 * Blakharaz' gescheiterter Versuch, ein Video mit libavcodec(ffmpeg) abzuspielen
 * - liegt als subsystem in engine/
 * - braucht ffdshow in depedencies, dort muss ffdshow/src/ffmpeg compiliert sein
 * @todo (1) diese Datei zum Kompilieren bringen (geht bei mir weder in C noch in C++)
 * @todo (2) in ein freundliches C++-Interface packen
 */


//#include "FfmpegVideo.h"
#include <libavcodec/avcodec.h>
#include <libavformat/avformat.h>

#define FALSE 0

	void* CreateFfmpegVideo(char* filename)
	{

		av_register_all();

		AVFormatContext *pFormatCtx;

		// Open video file
		if(av_open_input_file(&pFormatCtx, filename.c_str(), NULL, 0, NULL)!=0)
			handle_error(); // Couldn't open file

		// Retrieve stream information
		if(av_find_stream_info(pFormatCtx)<0)
			handle_error(); // Couldn't find stream information

		dump_format(pFormatCtx, 0, filename.c_str(), FALSE);

		return pFormatCtx;
	}

	void PlayFfmpegVideo(void* formatCtx)
	{

		AVFormatContext *pFormatCtx = (AVFormatContext*)formatCtx;

		int            i, videoStream;
		AVCodecContext *pCodecCtx;

		// Find the first video stream
		videoStream=-1;
		for(i=0; i<mFormatCtx->nb_streams; i++)
			if(mFormatCtx->streams[i]->codec->codec_type==CODEC_TYPE_VIDEO)
			{
				videoStream=i;
				break;
			}
		if(videoStream==-1)
			handle_error(); // Didn't find a video stream

		// Get a pointer to the codec context for the video stream
		pCodecCtx=&mFormatCtx->streams[videoStream]->codec;

		AVCodec *pCodec;

		// Find the decoder for the video stream
		pCodec=avcodec_find_decoder(pCodecCtx->codec_id);
		if(pCodec==NULL)
			handle_error(); // Codec not found

		// Inform the codec that we can handle truncated bitstreams -- i.e.,
		// bitstreams where frame boundaries can fall in the middle of packets
		if(pCodec->capabilities & CODEC_CAP_TRUNCATED)
			pCodecCtx->flags|=CODEC_FLAG_TRUNCATED;

		// Open codec
		if(avcodec_open(pCodecCtx, pCodec)<0)
			handle_error(); // Could not open codec

		// Hack to correct wrong frame rates that seem to be generated by some 
		// codecs
		/*if(pCodecCtx->frame_rate>1000 && pCodecCtx->f>frame_rate_base==1)
			pCodecCtx->frame_rate_base=1000;*/

		AVFrame* pFrame=avcodec_alloc_frame();
		

		AVFrame *pFrameRGB;
		int     numBytes;
		uint8_t *buffer;

		// Allocate an AVFrame structure
		pFrameRGB=avcodec_alloc_frame();
		if(pFrameRGB==NULL)
			handle_error();

		// Determine required buffer size and allocate buffer
		numBytes=avpicture_get_size(PIX_FMT_RGB24, pCodecCtx->width,
			pCodecCtx->height);
		buffer=new uint8_t[numBytes];

		// Assign appropriate parts of buffer to image planes in pFrameRGB
		avpicture_fill((AVPicture *)pFrameRGB, buffer, PIX_FMT_RGB24,
			pCodecCtx->width, pCodecCtx->height);

		while(getNextFrame(mFormatCtx, pCodecCtx, videoStream, pFrame))
		{
			img_convert((AVPicture *)pFrameRGB, PIX_FMT_RGB24, (AVPicture*)pFrame, 
				pCodecCtx->pix_fmt, pCodecCtx->width, pCodecCtx->height);

			// Process the video frame (save to disk etc.)
			mTexture->getBuffer()->blitFromMemory(pFrameRGB);
		}
	};

	int GetNextFrame(AVFormatContext *pFormatCtx, AVCodecContext *pCodecCtx, 
		int videoStream, AVFrame *pFrame)
	{
		static AVPacket packet;
		static int      bytesRemaining=0;
		static uint8_t  *rawData;
		static bool     fFirstTime=true;
		int             bytesDecoded;
		int             frameFinished;

		// First time we're called, set packet.data to NULL to indicate it
		// doesn't have to be freed
		if(fFirstTime)
		{
			fFirstTime=false;
			packet.data=NULL;
		}

		// Decode packets until we have decoded a complete frame
		while(true)
		{
			// Work on the current packet until we have decoded all of it
			while(bytesRemaining > 0)
			{
				// Decode the next chunk of data
				bytesDecoded=avcodec_decode_video(pCodecCtx, pFrame,
					&frameFinished, rawData, bytesRemaining);

				// Was there an error?
				if(bytesDecoded < 0)
				{
					fprintf(stderr, "Error while decoding frame\n");
					return false;
				}

				bytesRemaining-=bytesDecoded;
				rawData+=bytesDecoded;

				// Did we finish the current frame? Then we can return
				if(frameFinished)
					return true;
			}

			// Read the next packet, skipping all packets that aren't for this
			// stream
			do
			{
				// Free old packet
				if(packet.data!=NULL)
					av_free_packet(&packet);

				// Read new packet
				if(av_read_packet(pFormatCtx, &packet)<0)
					goto loop_exit;
			} while(packet.stream_index!=videoStream);

			bytesRemaining=packet.size;
			rawData=packet.data;
		}

	loop_exit:

		// Decode the rest of the last frame
		bytesDecoded=avcodec_decode_video(pCodecCtx, pFrame, &frameFinished, 
			rawData, bytesRemaining);

		// Free last packet
		if(packet.data!=NULL)
			av_free_packet(&packet);

		return frameFinished!=0;
	};
